# Задача 16: Требуется вычислить, сколько раз встречается некоторое
# число X в массиве A[1..N]. Пользователь в первой строке вводит
# натуральное число N – количество элементов в массиве. В последующих
# строках записаны N целых чисел Ai
# . Последняя строка содержит число X


# Задача 18: Требуется найти в массиве A[1..N] самый близкий по
# величине элемент к заданному числу X. Пользователь в первой строке
# вводит натуральное число N – количество элементов в массиве. В
# последующих строках записаны N целых чисел Ai
# . Последняя строка
# содержит число X


# Задача 20: В настольной игре Скрабл (Scrabble) каждая буква имеет определенную
# ценность. В случае с английским алфавитом очки распределяются так:
# ● A, E, I, O, U, L, N, S, T, R – 1 очко;
# ● D, G – 2 очка;
# ● B, C, M, P – 3 очка;
# ● F, H, V, W, Y – 4 очка;
# ● K – 5 очков;
# ● J, X – 8 очков;
# ● Q, Z – 10 очков.
# А русские буквы оцениваются так:
# ● А, В, Е, И, Н, О, Р, С, Т – 1 очко;
# ● Д, К, Л, М, П, У – 2 очка;
# ● Б, Г, Ё, Ь, Я – 3 очка;
# ● Й, Ы – 4 очка;
# ● Ж, З, Х, Ц, Ч – 5 очков;
# ● Ш, Э, Ю – 8 очков;
# ● Ф, Щ, Ъ – 10 очков.
# Напишите программу, которая вычисляет стоимость введенного пользователем слова.
# Будем считать, что на вход подается только одно слово, которое содержит либо только
# английские, либо только русские буквы.

# Задача №25. Решение в группах
# Напишите программу, которая принимает на вход
# строку, и отслеживает, сколько раз каждый символ
# уже встречался. Количество повторов добавляется к
# символам с помощью постфикса формата _n.
# Input: a a a b c a a d c d d
# Output: a a_1 a_2 b c a_3 a_4 d c_1 d_1 d_2
# Для решения данной задачи используйте функцию
# .split()

# def count_simbs(simbs):
#     new_simbs = []
#     for i in range (len(simbs)): # Проходим по каждому индексу в списке simbs
#         n = simbs[:i+1].count(simbs[i])-1 # Вычисляем количество встреч символа в подсписке до i, и вычитаем 1
#         if n==0: # Если символ встречается впервые, добавляем его в new_simbs без постфикса
#             new_simbs.append(simbs[i])
#         else: # Если символ встречается не впервые, добавляем его в new_simbs с постфиксом "_n"
#             new_simbs.append(f"{simbs[i]}_{n}")
#     return " ".join(new_simbs) # Возвращаем новые символы, объединенные в строку через пробел


# string = "a a a b c a a d c d d"
# list_1 = string.split() # Разбиваем входную строку на отдельные символы
# new_list = count_simbs(list_1) # Вызываем функцию count_simbs для обработки списка символов
# print(new_list)  # Выводим полученный результат на экран

# Теперь давайте разберем, как работает данная программа:

# 1. Функция `count_simbs()` принимает список символов `simbs` в качестве аргумента.
# 2. Внутри функции создается пустой список `new_simbs`, куда будут добавляться символы с постфиксом "_n" в соответствии с количеством их встреч.
# 3. Далее происходит итерация по индексам в списке символов `simbs`. Для каждого символа подсчитывается количество его встреч в подсписке до текущего индекса `i` с помощью `simbs[:i+1].count(simbs[i])`. Затем из этого количества вычитается 1, так как символ на текущем индексе учитывается лишний раз.
# 4. Если количество встреч равно 0, то это значит, что символ встречается впервые, и он добавляется в `new_simbs` без постфикса. В противном случае, к символу добавляется постфикс "_n" и он также добавляется в `new_simbs`.
# 5. В конце функция возвращает результат, полученный путем объединения элементов списка `new_simbs` в одну строку через пробел с помощью `join()`.
# 6. После определения функции программа разбивает входную строку на список символов `list_1`, вызывает функцию `count_simbs()` для обработки списка символов и выводит полученный результат на экран.     


# В представленном фрагменте кода переменная `b` содержит строку символов, представленных через пробел. Затем строка разбивается на отдельные символы 
# с помощью метода `split(" ")`, и каждый символ обрабатывается в цикле. Давайте подробно разберем, как работает этот фрагмент кода:
# b = "a a a b c a a d c d d"
# a = " " # Создается переменная "a" типа string со значением "пробел"
# b = b.split(" ") # Разбиваем строку "b" на отдельные символы с помощью пробела в качестве разделителя
# for i in b:  # Проходим циклом по каждому символу в списке "b"
#     count_1 = a.count(i)  # Считаем количество вхождений символа "i" в строке "a"
#     print(count_1) # Выводим количество вхождений на экран
#     if a.count(i) == 0: # Если символ встречается в "a" впервые
#         a = a + i # Добавляем символ к "a" без постфикса
#     else: # Если символ встречается не впервые
#         a += i + "_" + str(count_1)+ "  "# Добавляем символ к "a" с постфиксом "_n" (количество вхождений)
# print(a.strip()) # Выводим значение "a", удаляя начальные и конечные пробелы

# Теперь давайте разберем, что происходит на каждой итерации цикла:

# 1. Для каждого символа `i` в списке `b`, программа сначала считает количество вхождений этого символа в строке `a` с помощью `a.count(i)`. 
# Результат записывается в переменную `count_1`.
# 2. Далее программа проверяет, если количество вхождений `count_1` равно 0, это означает, 
# что символ встречается впервые. В этом случае символ добавляется к строке `a` без постфикса.
# 3. В противном случае, если символ уже встречался в строке `a`, к нему добавляется постфикс "_n" 
# (где n - количество вхождений) и он также добавляется к строке `a`.
# 4. После завершения цикла выводится значение переменной `a`, удаляя начальные и конечные пробелы.
# Это происходит потому, что программа обрабатывает каждый символ в строке `b`, подсчитывает их вхождения в строке `a` и формирует строку `a` с учетом вхождений символов.





# Задача №27. Решение в группах
# Пользователь вводит текст(строка). Словом считается
# последовательность непробельных символов идущих
# подряд, слова разделены одним или большим числом
# пробелов. Определите, сколько различных слов
# содержится в этом тексте.
# Input: She sells sea shells on the sea shore The shells
# that she sells are sea shells I'm sure.So if she sells sea
# shells on the sea shore I'm sure that the shells are sea
# shore shells
# Output: 13




# def count_unique_words(text):
#     word_list = text.split()  # Разбиваем входной текст на список слов
#     unique_words = set(word_list)  # Создаем множество уникальных слов
#     return len(unique_words)  # Возвращаем количество уникальных слов

# input_text = "She sells sea shells on the sea shore;The shells that she sells are sea shells I'm sure.So if she sells sea shells on the sea shore,I'm sure that the shells are sea shore shells."

# result = count_unique_words(input_text)
# print(result)


# import re
# def count_unique_words(text):
#     # Приводим весь текст к нижнему регистру
#     text = text.lower()
#     # Используем регулярное выражение для разделения на слова
#     word_list = re.findall(r'\b\w+\b', text)
#     unique_words = set(word_list)  # Создаем множество уникальных слов
#     return len(unique_words)  # Возвращаем количество уникальных слов

# input_text = "She sells sea shells on the sea shore;The shells that she sells are sea shells I'm sure.So if she sells sea shells on the sea shore,I'm sure that the shells are sea shore shells."

# result = count_unique_words(input_text)
# print(result)

# Задача №29. Решение в группах
# Ваня и Петя поспорили, кто быстрее решит
# следующую задачу: “Задана последовательность
# неотрицательных целых чисел. Требуется определить
# значение наибольшего элемента
# последовательности, которая завершается первым
# встретившимся нулем (число 0 не входит в
# последовательность)”. Однако 2 друга оказались не
# такими смышлеными. Никто из ребят не смог до
# конца сделать это задание. Они решили так: у кого
# будет меньше ошибок в коде, тот и выиграл спор. За
# помощью товарищи обратились к Вам, студентам.

# Ваня:
# n = int(input())
# max_number = 1000
# while n != 0:
#  n = int(input())
#  if max_number > n:
#  max_number = n
# print(max_number)

# Петя:
# n = int(input())
# max_number = -1
# while n < 0:
#  n = int(input())
#  if max_number < n:
#  n = max_number
# print(n) 


import random

def generate_polynomial(k):
    coefficients = [random.randint(-10, 10) for _ in range(k+1)]  # Генерируем случайные коэффициенты
    coefficients_str = [f"{coeff} * x^{index}" if index > 1 else (f"{coeff} * x" if index == 1 else str(coeff)) for index, coeff in enumerate(coefficients)][::-1]  # Преобразуем коэффициенты в строковое представление многочлена
    polynomial = " + ".join(coefficients_str) + " = 0"  # Собираем строку с многочленом
    return polynomial

k = int(input("Введите степень многочлена k: "))
result = generate_polynomial(k)
print(result)




