
# Задача №39. Решение в группах
# Даны два массива чисел. Требуется вывести те элементы
# первого массива (в том порядке, в каком они идут в первом
# массиве), которых нет во втором массиве. Пользователь вводит
# число N - количество элементов в первом массиве, затем N
# чисел - элементы массива. Затем число M - количество
# элементов во втором массиве. Затем элементы второго массива


# lst1 = [1,2,3,4,5]
# lst2 = [1,2,1,2,1]

# # 1й вариант решения
# # for i in lst1:
# #     if i not in lst2:
# #         print(i, end = " ")
# # 2й вариант решения
# print([i for i in lst1 if i not in set(lst2)])


# Задача №41. Решение в группах
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.
# Ввод: 5
# 1 2 3 4 5
# Ввод: 5
# 1 5 1 5 1

# Вывод: 0
# Вывод: 2

# Программа для определения количества элементов, у которых два соседних элемента меньше данного

# Вводим количество элементов в массиве
# N = int(input("Введите количество элементов: ")) #- Запрашиваем у пользователя ввод количества элементов в массиве.

# # Инициализируем массив, записывая элементы, введенные пользователем
# array = [] #Инициализируем пустой массив для хранения введенных пользователем чисел.
# for _ in range(N):  #- Мы используем цикл for для запроса чисел у пользователя N раз и добавляем их в массив array.

#     num = int(input("Введите число: "))
#     array.append(num)

# # Подсчет количества элементов, у которых два соседних и, при этом, оба соседних элемента меньше данного
# count = 0 # - Инициализируем переменную count для хранения количества элементов соответствующего условию.

# for i in range(1, N - 1):  # От первого до предпоследнего элемента.  - Мы запускаем цикл для прохождения по массиву (начиная со второго элемента и заканчивая предпоследним).
#     if array[i] > array[i - 1] and array[i] > array[i + 1]:  # Если текущий элемент больше соседних.- Мы проверяем, удовлетворяет ли текущий элемент условию: он больше своих двух соседних.
#         count += 1 #Если условие выполняется, мы увеличиваем счетчик count.


# # Выводим результат
# print("Количество элементов, у которых оба соседних элемента меньше данного:", count)




# Задача №43. Решение в группах
# Дан список чисел. Посчитайте, сколько в нем пар
# элементов, равных друг другу. Считается, что любые
# два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать. Вводится список
# чисел. Все числа списка находятся на разных
# строках.
# Ввод: 1 2 3 2 3
# Вывод: 2

# lst1 = [1,2,3,2,3]
# st = set(lst1)
# print(sum([lst1.count(i)// 2 for i in st]))


# Задача №45. Решение в группах
# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 105
# . Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).
# Ввод: 300     Вывод: 220 284

# k = int(input ("Введите число: "))
 
# def find_sum_divisors(number):
#     total_sum = 0
#     for i  in range(1, int(number**0.5)+1):
#         if number % i ==0:
#             total_sum +=i
#             if i != number //i:
#                 total_sum += (number // i)
#     return total_sum - number
# print(*((i, first) for i in range(2, k+1) if i == find_sum_divisors(first := find_sum_divisors(i)) and i <first))




# # Начало урока
# from random import randint #Этот оператор импортирует функцию randint из модуля random, который генерирует случайное целое число в указанном диапазоне.

# def create_list(lower, upper, count):#Это объявление функции с именем create_list, которая принимает три аргумента: lower (нижняя граница диапазона),
#                                      # upper (верхняя граница диапазона) и count (количество элементов, которые нужно сгенерировать).
#     res = [] #Эта строка инициализирует пустой список с именем res, в который будут добавляться случайно сгенерированные числа.
#     for i in range (count): #Это начало цикла, который будет выполняться count раз (то есть столько, сколько было передано в функцию).
#         res.append(randint(lower, upper))#В этой строке случайное целое число в диапазоне от lower до upper (включительно) добавляется в список res при помощи функции append.
#     return res #После завершения цикла, список res возвращается как результат выполнения функции.
# print(create_list(-5,10,5)) #Эта строка вызывает функцию create_list с аргументами -5, 10, 5 и
#                             # выводит результат (сгенерированный список из 5 случайных чисел в диапазоне от -5 до 10) на экран.
# print( [randint(-5,10) for _ in range(5)])

# sp = [ i for i in range(10)]
# print(sp)

# print([i**2 for i in sp])
# print([i**2 for i in sp if i%2])
# print([i**2  if i%2 else 0 for i in sp ])



# from random import randint #- Этот оператор импортирует функцию randint
#                            #из модуля random, который генерирует случайное целое число в указанном диапазоне.
# n = int(input("Введите число: ")) #В этой строке кода пользователю предлагается ввести число, которое сохраняется в переменной n как целое число (при помощи int(input(...))).

# print(lst1 :=[randint(0,10) for i in range(n)]) #- В этой строке создается список lst1 из n случайных чисел в диапазоне от 0 до 10 с использованием list comprehension 
#                                                 #и функции randint. Он выводится на экран и сохраняется в lst1 при 
#                                                 #помощи оператора присваивания := (добавленного в Python 3.8).
# print(lst2 := [randint(0,10) for i in range(n)])#Аналогично для списка lst2 - генерация n случайных чисел в диапазоне от 0 до 10, вывод на экран и 
#                                                 #сохранение в lst2 при помощи оператора присваивания :=.
# print(*[i for i in lst1 if i not in set(lst2)]) #Эта строка создает новый список, содержащий элементы из lst1, которые не присутствуют в lst2. 
#                                                 #Он распаковывается и выводится на экран при помощи *.
# #Таким образом, в итоге пользователь вводит число n, а затем выводятся два списка (lst1 и lst2), 
# #после чего выводится список элементов, которые присутствуют в lst1, но отсутствуют в lst2.                                                




lst1 = [1,5,1,5,1,5] #- Создается список lst1 с элементами [1, 5, 1, 5, 1, 5].
sp = [i for i in range(len(lst1)) if lst1[i-1] < lst1[i] and lst1[i] > lst1[(i+1) % len(lst1)]]
# - Здесь создается список sp, который содержит индексы элементов списка lst1, удовлетворяющих определенному условию. 
# Давайте подробнее разберем это выражение:
#    - for i in range(len(lst1)) - Цикл проходит по индексам элементов списка.
#    - if lst1[i-1] < lst1[i] and lst1[i] > lst1[(i+1) % len(lst1)] - Здесь проверяется условие: элемент lst1[i] больше
#    предыдущего элемента lst1[i-1] и больше следующего элемента lst1[(i+1) % len(lst1)] (при этом % len(lst1) позволяет 
#   обеспечить "зацикленность" списка,  чтобы корректно обрабатывать соседние элементы для первого и последнего элементов списка).
print(sum(sp))

# Таким образом, данный код находит все элементы в списке lst1, которые больше своих соседних элементов (i-1 и i+1), 
# и выводит сумму индексов этих элементов в исходном списке lst1. В данном конкретном случае,
# суммируются индексы элементов 1 и 3 (с учетом индексации, начинающейся с 0), что приводит к результату 4.





